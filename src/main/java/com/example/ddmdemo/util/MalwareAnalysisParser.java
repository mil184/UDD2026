package com.example.ddmdemo.util;

import com.example.ddmdemo.model.MalwareAnalysis;
import com.example.ddmdemo.model.ThreatClassification;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.springframework.stereotype.Component;

@Component
public class MalwareAnalysisParser {

    // -------------- KEY:VALUE SUPPORT (your existing approach) --------------
    private static final Pattern KEY_VALUE_LINE =
            Pattern.compile("(?m)^\\s*([^:\\n]{2,60})\\s*:\\s*(.*?)\\s*$");

    private static final Pattern HASH_PATTERN =
            Pattern.compile("(?i)\\b([a-f0-9]{32}|[a-f0-9]{64})\\b");

    private static final Map<String, String> KEY_ALIASES = Map.ofEntries(
            Map.entry("ime i prezime", "analystFullName"),
            Map.entry("ime i prezime forenzicara", "analystFullName"),
            Map.entry("ime i prezime forenzičara", "analystFullName"),
            Map.entry("forenzicar", "analystFullName"),
            Map.entry("forenzičar", "analystFullName"),
            Map.entry("analyst", "analystFullName"),
            Map.entry("analyst full name", "analystFullName"),
            Map.entry("full name", "analystFullName"),

            Map.entry("bezbednosna organizacija", "securityOrganization"),
            Map.entry("bezbednosna organizacija cert/csirt", "securityOrganization"),
            Map.entry("organizacija", "securityOrganization"),
            Map.entry("cert", "securityOrganization"),
            Map.entry("csirt", "securityOrganization"),
            Map.entry("security organization", "securityOrganization"),
            Map.entry("organization", "securityOrganization"),

            Map.entry("malware", "malwareName"),
            Map.entry("malver", "malwareName"),
            Map.entry("naziv malvera", "malwareName"),
            Map.entry("pretnja", "malwareName"),
            Map.entry("threat", "malwareName"),
            Map.entry("malware name", "malwareName"),

            Map.entry("opis", "behaviorDescription"),
            Map.entry("opis ponasanja", "behaviorDescription"),
            Map.entry("opis ponašanja", "behaviorDescription"),
            Map.entry("opis ponasanja malvera", "behaviorDescription"),
            Map.entry("description", "behaviorDescription"),
            Map.entry("behavior", "behaviorDescription"),
            Map.entry("behaviour", "behaviorDescription"),

            Map.entry("klasifikacija", "threatClassification"),
            Map.entry("klasifikacija pretnje", "threatClassification"),
            Map.entry("klasifikacija prijetnje", "threatClassification"),
            Map.entry("classification", "threatClassification"),
            Map.entry("threat classification", "threatClassification"),

            Map.entry("uzorak", "sampleHash"),
            Map.entry("hash", "sampleHash"),
            Map.entry("hes", "sampleHash"),
            Map.entry("heš", "sampleHash"),
            Map.entry("md5", "sampleHash"),
            Map.entry("sha256", "sampleHash"),
            Map.entry("sample", "sampleHash"),
            Map.entry("sample hash", "sampleHash")
    );

    // -------------- TEMPLATE SUPPORT (your PDF image layout) --------------

    // Matches: "Organizacija <NAME>" or "Organizacija: NAME"
    private static final Pattern ORG_PATTERN =
            Pattern.compile("(?im)^\\s*Organizacija\\s*:?\\s*(.+?)\\s*$");

    // Matches: "Klasifikacija: <CLASS>, <HASH>" (hash may be hex or any string)
    private static final Pattern CLASS_AND_HASH_PATTERN =
            Pattern.compile("(?im)^\\s*Klasifikacija\\s*:\\s*([^,\\n]+)\\s*,\\s*([^\\n]+)\\s*$");

    // Matches: "... ukazuje na <THREAT>. Opis ponašanja"
    private static final Pattern THREAT_IN_SENTENCE_PATTERN =
            Pattern.compile("(?is)ukazuje\\s+na\\s+(.+?)\\s*\\.\\s*Opis\\s+pona", Pattern.UNICODE_CASE);

    // Stop when we reach:
    // 1) a standalone name line (two words with capital letters)
    // 2) OR a line that starts with "Potpis"
    // 3) OR end of document
    private static final Pattern BEHAVIOR_BLOCK_PATTERN =
            Pattern.compile(
                    "(?is)malvera\\s*/\\s*pretnje\\s*:\\s*(.+?)(?=\\n\\s*[A-ZŠĐČĆŽ][a-zšđčćž]+\\s+[A-ZŠĐČĆŽ][a-zšđčćž]+\\s*$|\\n\\s*Potpis\\b|\\z)",
                    Pattern.UNICODE_CASE
            );

    // Captures:
    // 1) description after "malvera/pretnje:"
    // 2) analyst name line right before "Potpis ..."
    private static final Pattern BEHAVIOR_AND_ANALYST_PATTERN =
            Pattern.compile(
                    "(?is)malvera\\s*/\\s*pretnje\\s*:\\s*(.+?)\\s*\\n\\s*([A-ZŠĐČĆŽ][\\p{L}.'-]+\\s+[A-ZŠĐČĆŽ][\\p{L}.'-]+)\\s*\\n\\s*Potpis\\b"
            );

    // Fallback (if name line is missing)
    private static final Pattern BEHAVIOR_BLOCK_FALLBACK_PATTERN =
            Pattern.compile("(?is)malvera\\s*/\\s*pretnje\\s*:\\s*(.+?)(?=\\n\\s*Potpis\\b|\\z)");

    // Matches a name before "Potpis forenzičara"
    private static final Pattern ANALYST_NAME_PATTERN =
            Pattern.compile("(?is)\\n\\s*([^\\n]{2,80}?)\\s*\\n\\s*Potpis\\s+forenzi\\S*ara\\b");

    public MalwareAnalysis parse(String extractedText) {
        if (extractedText == null || extractedText.isBlank()) {
            return MalwareAnalysis.builder().build();
        }

        // Keep explicit variables (avoid builder.build() inside loops)
        String analystFullName = null;
        String securityOrganization = null;
        String malwareName = null;
        String behaviorDescription = null;
        ThreatClassification threatClassification = null;
        String sampleHash = null;

        // 1) Try KEY:VALUE parsing (works for your simple test PDFs)
        Matcher m = KEY_VALUE_LINE.matcher(extractedText);
        while (m.find()) {
            String rawKey = m.group(1);
            String rawValue = m.group(2);

            String normalizedKey = normalizeKey(rawKey);
            String canonical = KEY_ALIASES.get(normalizedKey);
            if (canonical == null) continue;

            String value = normalizeValue(rawValue);
            if (value.isBlank()) continue;

            switch (canonical) {
                case "analystFullName" -> {
                    if (analystFullName == null) analystFullName = value;
                }
                case "securityOrganization" -> {
                    if (securityOrganization == null) securityOrganization = value;
                }
                case "malwareName" -> {
                    if (malwareName == null) malwareName = value;
                }
                case "behaviorDescription" -> {
                    if (behaviorDescription == null) behaviorDescription = value;
                }
                case "threatClassification" -> {
                    if (threatClassification == null) {
                        threatClassification = parseClassification(value).orElse(null);
                    }
                }
                case "sampleHash" -> {
                    if (sampleHash == null) {
                        // prefer real md5/sha256 if present
                        sampleHash = extractHash(value).orElse(value);
                    }
                }
                default -> { /* ignore */ }
            }
        }

        // 2) TEMPLATE parsing (fill missing fields based on your image layout)

        if (securityOrganization == null) {
            securityOrganization = firstGroup(ORG_PATTERN, extractedText).map(String::trim).orElse(null);
        }

        if (threatClassification == null || sampleHash == null) {
            Matcher ch = CLASS_AND_HASH_PATTERN.matcher(extractedText);
            if (ch.find()) {
                String clsRaw = normalizeValue(ch.group(1));
                String hashRaw = normalizeValue(ch.group(2));

                if (threatClassification == null) {
                    threatClassification = parseClassification(clsRaw).orElse(null);
                }

                if (sampleHash == null) {
                    // first try strict md5/sha256 in hashRaw, otherwise keep raw text
                    sampleHash = extractHash(hashRaw).orElse(hashRaw);
                }
            }
        }

        if (malwareName == null) {
            malwareName = firstGroup(THREAT_IN_SENTENCE_PATTERN, extractedText)
                    .map(this::cleanInline)
                    .orElse(null);
        }

        // Try to capture behavior + analyst together (best for your template PDFs)
        if (behaviorDescription == null || analystFullName == null) {
            Matcher ba = BEHAVIOR_AND_ANALYST_PATTERN.matcher(extractedText);
            if (ba.find()) {
                if (behaviorDescription == null) {
                    behaviorDescription = cleanMultiline(ba.group(1));
                }
                if (analystFullName == null) {
                    analystFullName = cleanInline(ba.group(2));
                }
            }
        }

        // Fallback: if still missing behavior, capture until "Potpis"
        if (behaviorDescription == null) {
            behaviorDescription = firstGroup(BEHAVIOR_BLOCK_FALLBACK_PATTERN, extractedText)
                    .map(this::cleanMultiline)
                    .orElse(null);
        }

        // 3) Global fallback hash scan (if still missing)
        if (sampleHash == null) {
            sampleHash = extractHash(extractedText).orElse(null);
        }

        return MalwareAnalysis.builder()
                .analystFullName(analystFullName)
                .securityOrganization(securityOrganization)
                .malwareName(malwareName)
                .behaviorDescription(behaviorDescription)
                .threatClassification(threatClassification)
                .sampleHash(sampleHash)
                .build();
    }

    private static String normalizeKey(String key) {
        return key == null ? "" : key
                .trim()
                .toLowerCase(Locale.ROOT)
                .replaceAll("\\s+", " ");
    }

    private static String normalizeValue(String value) {
        return value == null ? "" : value
                .trim()
                .replaceAll("\\s+", " ");
    }

    private Optional<String> firstGroup(Pattern pattern, String text) {
        Matcher mm = pattern.matcher(text);
        if (mm.find()) return Optional.ofNullable(mm.group(1));
        return Optional.empty();
    }

    private String cleanInline(String s) {
        if (s == null) return null;
        return s.replaceAll("[<>]", "").trim();
    }

    private String cleanMultiline(String s) {
        if (s == null) return null;
        // keep line breaks but normalize whitespace
        String cleaned = s.replaceAll("\\r", "").trim();
        // If your PDFBox extraction produces lots of extra blank lines, you can compress them:
        cleaned = cleaned.replaceAll("\\n{3,}", "\n\n");
        return cleaned;
    }

    private static Optional<String> extractHash(String text) {
        if (text == null) return Optional.empty();
        Matcher hm = HASH_PATTERN.matcher(text);
        if (hm.find()) return Optional.of(hm.group(1));
        return Optional.empty();
    }

    private static Optional<ThreatClassification> parseClassification(String input) {
        if (input == null) return Optional.empty();
        String v = input.trim().toLowerCase(Locale.ROOT);

        return switch (v) {
            case "niska", "low" -> Optional.of(ThreatClassification.LOW);
            case "srednja", "medium" -> Optional.of(ThreatClassification.MEDIUM);
            case "visoka", "high" -> Optional.of(ThreatClassification.HIGH);
            case "kriticna", "kritična", "critical" -> Optional.of(ThreatClassification.CRITICAL);
            default -> Optional.empty();
        };
    }
}